1. Editor mode:

1.1 document file operations:

1.1.1 new document

1.1.2 save document

1.1.3 load document

1.2 show/edit global declarations. The declarations can be quite long. Normally we have full text editor, I am not sure how to integrate it with the command pattern. The proposed "language-specification.txt" refers to PCDATA, unfortunately it has much richer syntax, close to C language. Perhaps we could offer a "wizard" for editing declarations statement by statement:

1.2.1 show/edit/remove a statement (statements are usually separated by semicolon, thus easy to parse individual pieces of "PCDATA", except structs and functions which are enclosed with curly braces, but still doable).

1.2.2 add/replace constant declaration (which consists of type, name and value)

1.2.4 add/replace variable declaration (consists of type, name and optional initializer)

1.2.3 add/replace type declaration (consists of a name and type declaration, which can be int, array, struct)
1.2.5 add/replace function declaration (which can recursively call the wizard to add the inner function declarations and in addition functional code statements, so perhaps we have a "function-editing" mode here).

1.3 show template names and their parameters (each parameter has a type and a name)

1.4 show/edit system declarations (long text again, similar to declarations, but in addition it has template instantiations with syntax is similar to function calls, "system" statement and a few more optional statements like "gantt", "progress", "before_update", "after_update").

1.5 add a (timed automaton) template

1.6 import (timed automata) templates from another model document:

1.6.1 select a model document file

1.6.2 show the list of templates available in that model document

1.6.3 select the templates and import them into the current document

1.7 show/edit a template:

1.7.1 show/edit template name

1.7.2 show/edit template parameters

1.7.3 edit template local declarations

1.7.4 show/edit template automaton:

1.7.4.1 add/remove location, edge, branchpoint

1.7.4.2 show/edit location labels (name, invariant, exponential rate)

1.7.4.3 edit the edge by changing source and destination (specify location and/or branchpoint)

1.7.4.4 edit edge labels (select statement, guard, synchronization, update, action, probabilistic weight)

2. Simulator mode:

2.1 show current state:

2.1.1 show processes and their current locations (either all or one-by-one):

2.1.1.1 show a list of processes and allow to select a process

2.1.1.2 show the current location of the selected process (perhaps allow inspecting the outgoing edges from that location and edges leading to that location)

2.1.2 show variable values (either all or one-by-one):

2.1.2.1 show list of variable names and show the value of the selected one variable

2.1.2.2 variable name and value pairs. Note that variable values can be integers, arrays or structures with named fields.

2.1.3 show clock constraints, expressions like x\in(3,5] and x-y\in[6,inf):

2.1.3.1 show a list of clocks and clock differences, allow to select one

2.1.3.2 show the bound for the selected clock or clock difference.

2.2 show the transition options available from the current state (either all or one-by-one):

2.2.1 show one transition: processes involved, edges, "select" values

2.2.2 fire one transition by a appending it to the current position of the trace

2.3 show/edit the trace (a sequence of interleaving states and transitions) (probably one-by-one):

2.3.1 show the currently selected state or transition (show transition similarly to transition options and also show the state with constraints when the transition is enabled)

2.3.2 select a previous/next state/transition in the trace, perhaps announce the state changes this transition introduces.

2.4 File operations

2.4.1 Save trace to a file

2.4.2 Load trace from a file

2.5 The simulators also have Message Sequence Chart, Gantt chart, automata coverage information. They do not provide any new information of what has already been shown in the state display, but rather summarize an entire trace in one big picture.

3. Verifier

3.1 Query file operations (normally queries are stored with the document file, but they can also be in a separate q-file):

3.1.1 Import queries from q-file

3.1.2 Export queries to q-file

3.2 Show/edit a list of queries:

3.2.1 Show/remove a selected query (currently verifier shows either query formular or query comment -- the mode can be changed).

3.2.2 Show query status from previous verification (satisfied/not satisfied/unknown/error, confidence interval, simulation trajectory and probability plots: probability density, cumulative probability, simple frequency counts over steps, time or cost; each plot also has technical comments like the span and mean of values).

3.2.3 Insert/append a new query into the selected position of query list

3.2.4 Edit a selected query:

3.2.4.1 Show/edit query formula

3.2.4.2 Show/edit query comment

3.2.5 Select one or more queries and check. Verification can take a long time and Uppaal may display runtime information such as CPU time usage, memory usage and load, also provide an option to cancel verification. The verification completes with a result: message, status, trace (which can be loaded into simulator).
3.3 Show/edit verification options:

3.3.1 Show an option, its current choice and possible choices/values.

3.3.2 Edit the current option by changing choice and/or enter a value.

4. Help (it is not currently accessible through the model+engine API, but this is how it looks like in Uppaal)

4.1 Traverse a tree of topics:

4.1.1 Select a topic, show subtopics, select the subtopic, parent topic

4.1.2 Select a topic and show its text

4.2 Search for a phrase

4.2.1 Enter a phrase to search for

4.2.2 Show the list of topics where there phrase is found

4.2.3 Select a topic and show its text

4.2.4 Select a topic and jump to the selected position in the tree of topics
